(in-package :netuno)

(defvar *address* "46.23.95.107")
(defvar *port* 11111)
(defvar *socket* nil)
(defvar *listen-thread* nil)
(defvar *player-threads* (make-hash-table :test 'equal))
(defvar *connections* (make-hash-table :test 'equal))
(defvar *player-conns* (make-hash-table :test 'equal))
(defvar *challenge* nil)
(defvar *forced-card* (make-hash-table :test 'equal))
(defvar *command-parser* (create-scanner "(\\w+)\\s*(\\d+)?\\s*(\\w+)?"))

(defun send-message (conn string)
  (let ((bytes (flexi-streams:string-to-octets string))
	(crlf (flexi-streams:string-to-octets (format nil "~c~c" #\Return #\Linefeed))))
    (dotimes (i (length bytes))
      (write-byte (aref bytes i) (socket-stream conn)))
    (dotimes (i (length crlf))
      (write-byte (aref crlf i) (socket-stream conn)))
    (force-output (socket-stream conn))))

(defun show-players-conn (conn)
  (send-message conn (format nil "List of players: ~{~a~^, ~}" (mapcar (lambda (player) (format nil "~a:~d" player (length (get-hand player)))) *players*))))

(defun show-players (name)
  (let ((conn (gethash name *player-conns*)))
    (show-players-conn conn)))

(defun show-player-hand (name)
  (let ((conn (gethash name *player-conns*)))
    (when conn
      (send-message conn (format nil "Your hand: ~a"
				 (hand-to-string (get-hand name)))))))

(defun show-top-card (&optional (name nil))
  (flet ((show-top-card-conn (c)
	   (send-message c
	   (format nil "Top card is: ~a"
		   (card-to-string *top-card*)))))

    (if name
	(let ((conn (gethash name *player-conns*)))
          (show-top-card-conn conn))
	(maphash (lambda (c n)
		   (declare (ignore n))
		   (show-top-card-conn c))
		 *connections*))))

(defun show-current-turn (&optional (name nil))
  (flet ((show-current-turn-conn (c n)
	   (if (equal n (current-player))
	       (send-message c "It's your turn")
	       (send-message c (format nil "It's ~a's turn" (current-player))))))
    (if name
	(let ((conn (gethash name *player-conns*)))
	  (show-current-turn-conn conn name))
	(maphash (lambda (c n)
		   (show-current-turn-conn c n))
		 *connections*))))

(defun is-winner (player)
  (and (= (length (get-hand player)) 0) (gethash player *uno*)))

(defun announce-turn ()
  (let ((winner (find-if #'is-winner *players*)))
    (if winner
	(progn
	  (reset-game winner)
	  (maphash (lambda (conn name)
		     (send-message conn (format nil "~a wins!" winner))
		     (send-message conn "Starting new game")
		     (show-player-hand name)
		     (show-top-card name)
		     (show-current-turn name))
		   *connections*))
	(let ((name (current-player)))
	  (show-current-turn)
	  (show-top-card)
	  (show-player-hand name)))))

(defun read-bytes-line (stream)
  (labels ((read-line-rec (stream)
	     (let ((byte (read-byte stream nil)))
	       (if (or (null byte) (= byte 13))
		   nil
		   (cons byte (read-line-rec stream))))))
    (read-line-rec stream)))

(defun get-connection-line (conn)
  (handler-case
      (let ((line (read-bytes-line (socket-stream conn))))
	(when line
	  (string-trim '(#\newline #\return #\space)
		       (flexi-streams:octets-to-string line))))
    (error (err)
      (declare (ignore err))
      "Bad input")))

(defun init-connection (conn)
  (show-players-conn conn)
  (send-message conn "Please choose a nickname:")
  (let ((name (get-connection-line conn)))
    (when name
      (if (not (null (gethash name *player-conns*)))
	  (progn
	    (send-message conn "Nickname already taken.")
	    (setf name (init-connection conn)))
	  (progn
	    (setf (gethash name *player-threads*) (current-thread))
	    (setf (gethash conn *connections*) name)
	    (setf (gethash name *player-conns*) conn)
	    (maphash (lambda (c n)
		       (declare (ignore n))
		       (send-message c (format nil "~a has joined the game" name)))
		     *connections*)
	    (add-player name)
	    (show-player-hand name)
	    (show-current-turn name)
	    (show-top-card name)
	    (send-message conn "This is a text-based game. Enter \"help\" for help on the commands."))))
    name))

(defun deinit-connection (conn name)
  (when name
    (remove-player name)
    (remhash conn *connections*)
    (remhash name *player-conns*)
    (remhash name *player-threads*)
    (maphash (lambda (c n)
	       (declare (ignore n))
	       (send-message c (format nil "~a has left" name)))
	     *connections*))
  (socket-close conn))

(defun set-wildcard-color (color-arg)
  (let ((color (find-if (lambda (color) (equal (aref color 0) (aref color-arg 0))) *colors*)))
    (setf *top-card* (cons (car *top-card*) color))))

(defun can-play-draw4 (hand top-card)
  (null (find-if (lambda (card) (equal (cdr card) (cdr top-card))) hand)))

(defun handle-draw4 (can-play player)
  (let* ((challenger (car *players*))
	 (challenger-conn (gethash challenger *player-conns*)))
    (send-message challenger-conn "Would you like to challenge the draw4? (y/n)")
    (setf *challenge* (list can-play player challenger))))

(defun challenge (predicate)
  (when *challenge*
    (let ((player-conn (gethash (cadr *challenge*) *player-conns*))
	  (challenger-conn (gethash (caddr *challenge*) *player-conns*)))
      (if predicate
	  (progn
	    (maphash (lambda (conn name)
		       (declare (ignore name))
		       (send-message conn (format nil "~a challenges ~a on their draw4" (caddr *challenge*) (cadr *challenge*))))
		     *connections*)
	    (send-message challenger-conn (format nil "~a's hand: ~a" (cadr *challenge*) (hand-to-string (get-hand (cadr *challenge*)))))
	    (if (car *challenge*)
		(progn
		  (maphash (lambda (conn name)
			     (declare (ignore name))
			     (send-message conn "The challenge failed!"))
			   *connections*)
		  (draw-n-cards-and-print (caddr *challenge*) 6 :conn challenger-conn :send-message #'send-message)
		  (next-turn))
		(progn
		  (maphash (lambda (conn name)
			     (declare (ignore name))
			     (send-message conn "The challenge succeeds!"))
			   *connections*)
		  (draw-n-cards-and-print (cadr *challenge*) 4 :conn player-conn :send-message #'send-message))))
	  (progn
	    (draw-n-cards-and-print (caddr *challenge*) 4 :conn challenger-conn :send-message #'send-message)
	    (next-turn)))
      (setf *challenge* nil)
      (announce-turn))))

(defun handle-connection (conn)
  (let ((name (init-connection conn)))
    (do ((line (get-connection-line conn)
	       (get-connection-line conn)))
	((or (null line) (and (>= (length line) 4) (equal (subseq line 0 4) "quit")))
	 nil)
      (let* ((words (cadr (multiple-value-list (scan-to-strings *command-parser* line))))
	     (command (when (and words (aref words 0)) (string-downcase (aref words 0))))
	     (card-number (when (and words (aref words 1)) (1- (parse-integer (aref words 1)))))
	     (color-arg (when (and words (aref words 2)) (string-downcase (aref words 2)))))
	(when command
	  (cond
	    ((equal command "help")
	     (send-message conn "say <text>: Say something to the other players.")
	     (send-message conn "players: Print the list of players along with the number of cards in their hand.")
	     (send-message conn "hand: Show your hand.")
	     (send-message conn "top: Show the top card.")
	     (send-message conn "turn: Show whose turn it is.")
	     (send-message conn "play <card number> <color?>: Play the card identified by number from your hand. If it is a wild card, the color argument is required.")
	     (send-message conn "draw: Draw a card. If you can play the card, you have to play it after drawing it.")
	     (send-message conn "uno: Call uno if you have a single card."))
	    ((and (> (length line) 5) (equal (subseq line 0 4) "say "))
	     (maphash (lambda (c n)
			(declare (ignore n))
			(send-message c (format nil "~a: ~a" name (subseq line 4 (length line)))))
		      *connections*))
	    ((equal command "players")
	     (show-players name))
	    ((equal command "hand")
	     (show-player-hand name))
	    ((equal command "top")
	     (show-top-card name))
	    ((equal command "turn")
	     (show-current-turn name))
	    ((equal command "y")
	     (challenge t))
	    ((equal command "n")
	     (challenge nil))
	    ((equal command "uno")
	     (if (/= (length (get-hand name)) 1)
		 (progn
		   (send-message conn "You have more than one card!"))
		 (progn
		   (setf (gethash name *uno*) t)
		   (maphash (lambda (conn n)
			      (declare (ignore n))
			      (send-message conn (format nil "~a calls uno!" name)))
			    *connections*))))
	    ((equal command "draw")
	     (cond
	       (*challenge*
		(send-message conn "A challenge is ongoing"))
	       ((not (equal (current-player) name))
		(send-message conn "It's not your turn!"))
	       (t
		(maphash (lambda (conn n)
			   (declare (ignore n))
			   (send-message conn (format nil "~a draws a card" name)))
			 *connections*)
		(let ((cards (draw-n-cards-and-print name 1 :conn conn :send-message #'send-message)))
		  (if (card-playable-p (car cards) *top-card*)
		      (progn
			(send-message conn "You have to play this card.")
			(show-player-hand name))
		      (progn
			(next-turn)
			(announce-turn)))))))
	    ((equal command "play")
	     (if *challenge*
		 (send-message conn "A challenge is ongoing")
		 (if (= (length *players*) 1)
		     (send-message conn "Wait until there are at least 2 players")
		     (let ((card (when card-number
				   (let ((hand (get-hand name)))
				     (if (or (< card-number 0) (>= card-number (length hand)))
					 (send-message conn "Invalid card number")
					 (nth card-number hand))))))
		       (if (not card)
			   (send-message conn "Please enter a card number. Use the \"hand\" command to see them.")
			   (cond
			     ((not (equal (current-player) name))
			      (send-message conn "It's not your turn!"))
			     ((not (card-playable-p card *top-card*))
			      (send-message conn (format nil "You can't play a ~a on a ~a"
							 (card-to-string card) (card-to-string *top-card*))))
			     ((and (or (equal (car card) "draw4") (equal (car card) "change color"))
				   (or (null color-arg)
				       (null (find-if (lambda (color) (equal (aref color-arg 0) (aref color 0))) *colors*))))
			      (send-message conn "Please enter a color after the card number when playing a wild card."))
			     ((and (gethash name *forced-card*) (not (equal (gethash name *forced-card*) card)))
			      (send-message conn (format nil "You have to play a ~a" (card-to-string (gethash name *forced-card*)))))
			     (t
			      (let ((old-top-card *top-card*))
				(play-card name card :send-message #'send-message :player-conns *player-conns*)
				(maphash (lambda (conn n)
					   (declare (ignore n))
					   (send-message conn (format nil "~a played ~a" name (card-to-string card))))
					 *connections*)
				(when (and (= (length (get-hand name)) 0) (null (gethash name *uno*)))
				  (send-message conn "You didn't call uno!")
				  (maphash (lambda (conn n)
					     (when (not (equal n name))
					       (send-message conn (format nil "~a didn't call uno!" name))))
					   *connections*)
				  (draw-n-cards-and-print name 1 :conn conn :send-message #'send-message))
				(setf (gethash name *forced-card*) nil)
				(let ((type (car *top-card*)))
				  (cond ((equal type "draw4")
					 (set-wildcard-color color-arg)
					 (handle-draw4 (can-play-draw4 (get-hand name) old-top-card) name))
					((equal type "change color")
					 (set-wildcard-color color-arg)
					 (announce-turn))
					(t (announce-turn))))))))))))
	    (t (send-message conn (format nil "~a" line)))))))
    (deinit-connection conn name)))

(defun accept-connections (sock)
  (do ((ready-socket (wait-for-input sock :timeout 5 :ready-only t)
		     (wait-for-input sock :timeout 5 :ready-only t)))
      (nil nil)
    (when ready-socket
      (let ((conn (socket-accept (car ready-socket) :element-type '(unsigned-byte 8))))
	(make-thread (lambda () (handle-connection conn)))))
    (maphash (lambda (name thread)
	       (when (not (thread-alive-p thread))
		 (deinit-connection (gethash name *player-conns*) name)))
	     *player-threads*)
    (with-lock-held (*players-lock*)
      (setf *players* (remove-if (lambda (player) (null (gethash player *player-threads*))) *players*)))))

(defun start-netuno ()
  (let* ((socket (socket-listen *address* *port*)))
    (setf *socket* socket)
    (setf *listen-thread*
	  (make-thread
	   (lambda () (accept-connections socket))
	   :name "listen-thread"))))

(defun start-and-wait ()
  (join-thread (start-netuno)))

(defun stop-netuno ()
  (maphash (lambda (c name) (declare (ignore name)) (socket-close c)) *connections*)
  (setf *connections* (make-hash-table :test 'equal))
  (setf *player-conns* (make-hash-table :test 'equal))
  (setf *players* '())
  (setf *challenge* nil)
  (setf *forced-card* (make-hash-table :test 'equal))
  (socket-close *socket*)
  (maphash (lambda (name thread)
	     (declare (ignore name))
	     (when (thread-alive-p thread)
	       (destroy-thread thread)))
	   *player-threads*)
  (setf *player-threads* (make-hash-table :test 'equal))
  (when (thread-alive-p *listen-thread*)
    (destroy-thread *listen-thread*))
  (setf *listen-thread* nil)
  (setf *socket* nil))
