(in-package :netuno)

(defvar *address* "10.0.0.74")
(defvar *port* 11111)
(defvar *listen-thread* nil)
(defvar *socket* nil)
(defvar *connections* (make-hash-table :test 'equal))
(defvar *player-conns* (make-hash-table :test 'equal))
(defvar *challenge* nil)
(defvar *command-parser* (create-scanner "(\\w+)\\s*(\\d+)?\\s*(\\w+)?"))

(defun show-players-conn (conn)
  (format (socket-stream conn) "List of players: ~{~A~^, ~}~C~%" *players* #\return)
  (force-output (socket-stream conn)))

(defun show-players (name)
  (let ((conn (gethash name *player-conns*)))
    (show-players-conn conn)))

(defun show-player-hand (name)
  (let ((conn (gethash name *player-conns*)))
    (when conn
      (format (socket-stream conn) "Your hand: ~a~C~%"
	      (hand-to-string (get-hand name)) #\return)
      (force-output (socket-stream conn)))))

(defun show-top-card (&optional (name nil))
  (flet ((show-top-card-conn (c)
	   (format (socket-stream c) "Top card is: ~a~C~%"
		   (card-to-string *top-card*) #\return)
	   (force-output (socket-stream c))))

    (if name
	(let ((conn (gethash name *player-conns*)))
          (show-top-card-conn conn))
	(maphash (lambda (c n)
		   (declare (ignore n))
		   (show-top-card-conn c))
		 *connections*))))

(defun show-current-turn (&optional (name nil))
  (flet ((show-current-turn-conn (c n)
	   (if (equal n (current-player))
	       (format (socket-stream c) "It's your turn~C~%" #\return)
	       (format (socket-stream c) "It's ~a's turn~C~%" (current-player) #\return))
	   (force-output (socket-stream c))))
    (if name
	(let ((conn (gethash name *player-conns*)))
	  (show-current-turn-conn conn name))
	(maphash (lambda (c n)
		   (show-current-turn-conn c n))
		 *connections*))))

(defun announce-turn ()
  (let ((name (current-player)))
    (show-current-turn)
    (show-top-card)
    (show-player-hand name)))

(defun get-connection-line (conn)
  (handler-case
      (string-trim '(#\newline #\return #\space)
		   (read-line (socket-stream conn) nil))
    (error (err)
      (declare (ignore err))
      "")))

(defun init-connection (conn)
  (show-players-conn conn)
  (format (socket-stream conn) "Please choose a nickname:~C~%" #\return)
  (force-output (socket-stream conn))
  (let* ((name (get-connection-line conn)))
    (when name
      (if (not (null (gethash name *player-conns*)))
	  (progn
	    (format (socket-stream conn) "Nickname already taken.~C~%" #\return)
	    (force-output (socket-stream conn))
	    (setf name (init-connection conn)))
	  (progn
	    (setf (gethash conn *connections*) name)
	    (setf (gethash name *player-conns*) conn)
	    (maphash (lambda (c n)
		       (declare (ignore n))
		       (format (socket-stream c) "~a has joined the game~C~%" name #\return)
		       (force-output (socket-stream c)))
		     *connections*)
	    (force-output (socket-stream conn))
	    (add-player name)
	    (show-player-hand name)
	    (show-current-turn name)
	    (show-top-card name)
	    (force-output (socket-stream conn)))))
    name))

(defun deinit-connection (conn name)
  (when name
    (remove-player name)
    (remhash conn *connections*)
    (remhash name *player-conns*)
    (maphash (lambda (c n)
	       (declare (ignore n))
	       (format (socket-stream c) "~a has left~C~%" name #\return)
	       (force-output (socket-stream c)))
	     *connections*))
  (socket-close conn))

(defun set-wildcard-color (color-arg)
  (let ((color (find-if (lambda (color) (equal (aref color 0) (aref color-arg 0))) *colors*)))
    (setf *top-card* (cons (car *top-card*) color))))

(defun can-play-draw4 (hand top-card)
  (null (find-if (lambda (card) (equal (cdr card) (cdr top-card))) hand)))

(defun handle-draw4 (can-play player)
  (let* ((challenger (car *players*))
	 (challenger-conn (gethash challenger *player-conns*)))
    (format (socket-stream challenger-conn) "Would you like to challenge the draw4?~C~%" #\return)
    (force-output (socket-stream challenger-conn))
    (setf *challenge* (list can-play player challenger))))

(defun challenge (predicate)
  (when *challenge*
    (let ((player-conn (gethash (cadr *challenge*) *player-conns*))
	  (challenger-conn (gethash (caddr *challenge*) *player-conns*)))
      (if predicate
	  (progn
	    (maphash (lambda (conn name)
		       (declare (ignore name))
		       (format (socket-stream conn) "~a challenges ~a on their draw4~C~%" (caddr *challenge*) (cadr *challenge*) #\return)
		       (force-output (socket-stream conn)))
		     *connections*)
	    (format (socket-stream challenger-conn) "~a's hand: ~a~C~%" (cadr *challenge*) (hand-to-string (get-hand (cadr *challenge*))) #\return)
	    (force-output (socket-stream challenger-conn))
	    (if (car *challenge*)
		(progn
		  (maphash (lambda (conn name)
			     (declare (ignore name))
			     (format (socket-stream conn) "The challenge failed!~C~%" #\return)
			     (force-output (socket-stream conn)))
			   *connections*)
		  (draw-n-cards-and-print (caddr *challenge*) 6 :stream (socket-stream challenger-conn))
		  (next-turn))
		(progn
		  (maphash (lambda (conn name)
			     (declare (ignore name))
			     (format (socket-stream conn) "The challenge succeeds!~C~%" #\return)
			     (force-output (socket-stream conn)))
			   *connections*)
		  (draw-n-cards-and-print (cadr *challenge*) 4 :stream (socket-stream player-conn)))))
	  (progn
	    (draw-n-cards-and-print (caddr *challenge*) 4 :stream (socket-stream challenger-conn))
	    (next-turn)))
      (setf *challenge* nil)
      (announce-turn))))

(defun handle-connection (conn)
  (let ((name (init-connection conn)))
    (do ((line (get-connection-line conn)
	       (get-connection-line conn)))
	((or (null line) (and (>= (length line) 4) (equal (subseq line 0 4) "quit")))
	 nil)
      (let* ((words (cadr (multiple-value-list (scan-to-strings *command-parser* line))))
	     (command (when (and words (aref words 0)) (string-downcase (aref words 0))))
	     (card-number (when (and words (aref words 1)) (1- (parse-integer (aref words 1)))))
	     (color-arg (when (and words (aref words 2)) (string-downcase (aref words 2)))))
	(cond
	  ((and (> (length line) 5) (equal (subseq line 0 4) "say "))
	   (maphash (lambda (c n)
		      (declare (ignore n))
		      (format (socket-stream c) "~a: ~a~C~%" name (subseq line 4 (length line)) #\return)
		      (force-output (socket-stream c)))
		    *connections*))
	  ((equal command "players")
	   (show-players name))
	  ((equal command "hand")
	   (show-player-hand name))
	  ((equal command "top")
	   (show-top-card name))
	  ((equal command "turn")
	   (show-current-turn name))
	  ((equal command "y")
	   (challenge t))
	  ((equal command "n")
	   (challenge nil))
	  ((equal command "draw")
	   (cond
	     (*challenge*
	      (format (socket-stream conn) "A challenge is ongoing~C~%" #\return)
	      (force-output (socket-stream conn)))
	     ((not (equal (current-player) name))
	      (format (socket-stream conn) "It's not your turn!~C~%" #\return)
	      (force-output (socket-stream conn)))
	     (t
	      (maphash (lambda (conn n)
			 (declare (ignore n))
			 (format (socket-stream conn) "~a draws a card~C~%" name #\return)
			 (force-output (socket-stream conn)))
		       *connections*)
	      (draw-n-cards-and-print name 1 :stream (socket-stream conn))
	      (announce-turn))))
	  ((equal command "play")
	   (if *challenge*
	       (progn
		 (format (socket-stream conn) "A challenge is ongoing~C~%" #\return)
		 (force-output (socket-stream conn)))
	     (if (= (length *players*) 1)
		 (progn
		   (format (socket-stream conn) "Wait until there are at least 2 players~C~%" #\return)
		   (force-output (socket-stream conn)))
		 (let ((card (when card-number
			       (let ((hand (get-hand name)))
				 (if (or (< card-number 0) (>= card-number (length hand)))
				     (progn
				       (format (socket-stream conn) "Invalid card number~C~%" #\return)
				       (force-output (socket-stream conn)))
				     (nth card-number hand))))))
		   (if (not card)
		       (progn
			 (format (socket-stream conn) "Please enter a card number. Use the \"hand\" command to see them~C~%" #\return)
			 (force-output (socket-stream conn)))
		       (cond
			 ((not (equal (current-player) name))
			  (format (socket-stream conn) "It's not your turn!~C~%" #\return)
			  (force-output (socket-stream conn)))
			 ((not (card-playable-p card *top-card*))
			  (format (socket-stream conn) "You can't play a ~a on a ~a~C~%"
				  (card-to-string card) (card-to-string *top-card*) #\return)
			  (force-output (socket-stream conn)))
			 ((and (or (equal (car card) "draw4") (equal (car card) "change color"))
			       (or (null color-arg)
				   (null (find-if (lambda (color) (equal (aref color-arg 0) (aref color 0))) *colors*))))
			  (format (socket-stream conn) "Please enter a color after the card number when playing a wild card~C~%" #\return)
			  (force-output (socket-stream conn)))
			 (t
			  (let ((old-top-card *top-card*))
			    (play-card name card :stream (socket-stream conn))
			    (maphash (lambda (conn n)
				       (declare (ignore n))
				       (format (socket-stream conn) "~a played ~a~C~%" name (card-to-string card) #\return)
				       (force-output (socket-stream conn)))
				     *connections*)
			    (let ((type (car *top-card*)))
			      (cond ((equal type "draw4")
				     (set-wildcard-color color-arg)
				     (handle-draw4 (can-play-draw4 (get-hand name) old-top-card) name))
				    ((equal type "change color")
				     (set-wildcard-color color-arg)
				     (announce-turn))
				    (t (announce-turn))))))))))))
	  (t
	   (progn
	     (format (socket-stream conn) "~a~C~%" line #\return)
	     (force-output (socket-stream conn)))))))
      (deinit-connection conn name)))

(defun accept-connections (sock)
  (do ((new-conn (socket-accept sock :element-type 'character)
		 (socket-accept sock :element-type 'character)))
      ((null new-conn) nil)
    (make-thread (lambda () (handle-connection new-conn)))))

(defun start-netuno ()
  (let* ((socket (socket-listen *address* *port*)))
    (setf *socket* socket)
    (setf *listen-thread*
	  (make-thread
	   (lambda () (accept-connections socket))
	   :name "listen-thread"))))

(defun stop-netuno ()
  (maphash (lambda (c name) (declare (ignore name)) (socket-close c)) *connections*)
  (setf *connections* (make-hash-table :test 'equal))
  (setf *player-conns* (make-hash-table :test 'equal))
  (setf *players* '())
  (setf *challenge* nil)
  (socket-close *socket*)
  (destroy-thread *listen-thread*)
  (setf *listen-thread* nil)
  (setf *socket* nil))
